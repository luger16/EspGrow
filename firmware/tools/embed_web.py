#!/usr/bin/env python3
"""
embed_web.py - Convert gzipped web assets to C header file for PROGMEM embedding

Reads all .gz files from web/build/ recursively and generates a C header file
containing PROGMEM arrays and a route table mapping URL paths to embedded data.
"""

import glob
import gzip
import sys
import re
from pathlib import Path
from typing import List, Tuple, Union

# Configuration
WEB_BUILD_DIR = Path(__file__).parent.parent.parent / "web" / "build"
OUTPUT_FILE = Path(__file__).parent.parent / "src" / "web_assets.h"

CONTENT_TYPE_MAP = {
    ".html": "text/html; charset=utf-8",
    ".js": "application/javascript",
    ".css": "text/css",
    ".json": "application/json",
    ".wasm": "application/wasm",
    ".svg": "image/svg+xml",
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".gif": "image/gif",
    ".webp": "image/webp",
    ".ico": "image/x-icon",
    ".font": "application/octet-stream",
    ".woff": "font/woff",
    ".woff2": "font/woff2",
    ".ttf": "font/ttf",
}


def sanitize_identifier(path: str) -> str:
    """Convert file path to valid C identifier."""
    # Remove leading slash and .gz extension
    name = path.lstrip("/").replace(".gz", "")
    # Replace special characters with underscores
    name = re.sub(r"[^a-zA-Z0-9_]", "_", name)
    # Prefix with 'web_' to avoid conflicts
    return f"web_{name}"


def get_content_type(file_path: str) -> str:
    """Detect content type from file extension."""
    # Get the extension before .gz
    path = file_path.replace(".gz", "")
    for ext, content_type in CONTENT_TYPE_MAP.items():
        if path.endswith(ext):
            return content_type
    return "application/octet-stream"


def is_cacheable(url_path: str) -> bool:
    """Determine if asset should be cached (immutable paths)."""
    return "/_app/immutable/" in url_path


def find_gz_files() -> List[Tuple[str, Union[Path, bytes]]]:
    files = []
    
    if not WEB_BUILD_DIR.exists():
        print(f"Error: {WEB_BUILD_DIR} does not exist", file=sys.stderr)
        sys.exit(1)
    
    found_urls = set()
    
    for gz_file in sorted(glob.glob(str(WEB_BUILD_DIR / "**" / "*.gz"), recursive=True)):
        file_path = Path(gz_file)
        
        if file_path.name == "robots.txt.gz":
            continue
        
        rel_path = file_path.relative_to(WEB_BUILD_DIR)
        url_path = "/" + str(rel_path).replace("\\", "/").replace(".gz", "")
        
        files.append((url_path, file_path))
        found_urls.add(url_path)
    
    for png_file in sorted(glob.glob(str(WEB_BUILD_DIR / "**" / "*.png"), recursive=True)):
        file_path = Path(png_file)
        rel_path = file_path.relative_to(WEB_BUILD_DIR)
        url_path = "/" + str(rel_path).replace("\\", "/")
        
        if url_path not in found_urls:
            with open(file_path, "rb") as f:
                png_data = f.read()
            gzipped_data = gzip.compress(png_data)
            files.append((url_path, gzipped_data))
    
    return files


def read_file_bytes(file_path: Path) -> bytes:
    """Read file as bytes."""
    with open(file_path, "rb") as f:
        return f.read()


def bytes_to_c_array(data: bytes) -> str:
    """Convert bytes to C array initialization string."""
    # Format as hex values, 16 per line
    hex_values = [f"0x{b:02x}" for b in data]
    lines = []
    for i in range(0, len(hex_values), 16):
        lines.append("    " + ", ".join(hex_values[i : i + 16]))
    return ",\n".join(lines)


def generate_header(files: List[Tuple[str, Union[Path, bytes]]]) -> str:
    """Generate C header file content."""
    header_guard = "WEB_ASSETS_H"
    
    lines = [
        "#ifndef WEB_ASSETS_H",
        "#define WEB_ASSETS_H",
        "",
        "#include <Arduino.h>",
        "#include <cstdint>",
        "#include <cstddef>",
        "",
        "// Auto-generated web assets",
        "// Generated by embed_web.py",
        "",
    ]
    
    # Generate PROGMEM arrays for each file
    for url_path, source in files:
        identifier = sanitize_identifier(url_path)
        if isinstance(source, bytes):
            data = source
        else:
            data = read_file_bytes(source)
        size = len(data)
        
        lines.append(f"// {url_path} ({size} bytes)")
        lines.append(f"const uint8_t {identifier}[] PROGMEM = {{")
        lines.append(bytes_to_c_array(data))
        lines.append("};")
        lines.append(f"const size_t {identifier}_len = {size};")
        lines.append("")
    
    # Generate route table structure
    lines.append("")
    lines.append("struct WebAsset {")
    lines.append("  const char* path;")
    lines.append("  const uint8_t* data;")
    lines.append("  size_t len;")
    lines.append("  const char* content_type;")
    lines.append("  bool cacheable;")
    lines.append("};")
    lines.append("")
    
    # Generate route table
    lines.append(f"const size_t WEB_ASSET_COUNT = {len(files)};")
    lines.append("const WebAsset WEB_ASSETS[] PROGMEM = {")
    
    for url_path, _ in files:
        identifier = sanitize_identifier(url_path)
        content_type = get_content_type(url_path)
        cacheable = "true" if is_cacheable(url_path) else "false"
        
        lines.append(f'  {{"{url_path}", {identifier}, {identifier}_len, "{content_type}", {cacheable}}},')
    
    lines.append("};")
    lines.append("")
    
    # Add helper function
    lines.append("// Helper function to find asset by path")
    lines.append("inline const WebAsset* web_find_asset(const char* path) {")
    lines.append("  for (size_t i = 0; i < WEB_ASSET_COUNT; i++) {")
    lines.append("    const WebAsset* asset = &WEB_ASSETS[i];")
    lines.append("    if (strcmp(asset->path, path) == 0) {")
    lines.append("      return asset;")
    lines.append("    }")
    lines.append("  }")
    lines.append("  return nullptr;")
    lines.append("}")
    lines.append("")
    
    lines.append("#endif  // WEB_ASSETS_H")
    
    return "\n".join(lines)


def main():
    """Main entry point."""
    print(f"Scanning {WEB_BUILD_DIR} for .gz files...")
    
    files = find_gz_files()
    
    if not files:
        print("Error: No .gz files found in web/build/", file=sys.stderr)
        sys.exit(1)
    
    print(f"Found {len(files)} files")
    
    # Generate header content
    header_content = generate_header(files)
    
    # Ensure output directory exists
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    
    # Write header file
    with open(OUTPUT_FILE, "w") as f:
        f.write(header_content)
    
    print(f"Generated {OUTPUT_FILE}")
    print(f"Total assets: {len(files)}")


if __name__ == "__main__":
    main()
